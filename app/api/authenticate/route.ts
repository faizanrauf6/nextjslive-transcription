import { createClient, DeepgramError } from "@deepgram/sdk";
import { NextRequest, NextResponse } from "next/server";
import Redis from "ioredis";

const redis = new Redis(process.env.REDIS_URL ?? "");

const DEEPGRAM_CACHE_KEY = process.env.DEEPGRAM_API_KEY ?? "";
const CACHE_TTL_SECONDS = 86400; // 24 hours

export async function GET(request: NextRequest) {
  const isDev = process.env.DEEPGRAM_ENV === "development";

  // Development: return local .env key
  if (isDev) {
    return NextResponse.json({
      key: process.env.DEEPGRAM_API_KEY ?? "",
    });
  }

  // Production
  try {
    const cachedKey = await redis.get(DEEPGRAM_CACHE_KEY);
    console.log("Cached key:", cachedKey);
    if (cachedKey) {
      return NextResponse.json({ key: cachedKey });
    }

    const deepgram = createClient(process.env.DEEPGRAM_API_KEY ?? "");
    const { result: projectsResult, error: projectsError } = await deepgram.manage.getProjects();

    if (projectsError || !projectsResult?.projects?.[0]) {
      throw new DeepgramError("Failed to fetch project info");
    }

    const project = projectsResult.projects[0];
    const { result: newKeyResult, error: newKeyError } =
      await deepgram.manage.createProjectKey(project.project_id, {
        comment: "Generated by Redis auth handler",
        scopes: ["member:read", "member:write", "usage:write"],
        tags: ["next.js", "redis-cached"],
      });

    if (newKeyError || !newKeyResult?.key) {
      throw new DeepgramError("Failed to generate Deepgram API key");
    }

    const key = newKeyResult.key;

    // Cache the new key in Redis
    await redis.set(DEEPGRAM_CACHE_KEY, key, "EX", CACHE_TTL_SECONDS);

    return NextResponse.json({ key });
  } catch (err) {
    console.error("Deepgram auth error:", err);
    return NextResponse.json(
      { error: "Unable to authenticate with Deepgram" },
      { status: 500 }
    );
  }
}
